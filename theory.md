# Остовное дерево минимальной степени
## Аннотация
Мы рассматриваем задачу построения остовного дерева для графа $G = (V, E)$, максимальная степень вершин которого минимальна среди всех остовных деревьев графа G. Покажем, что эта задача является  $\bf NP$-трудной. Далее опишем итеративный алгоритм аппроксимации за полиномиальное время. Он дает гарантию, что мы ошибемся не более чем на единицу.
## Введение
Задачу остовного дерева изучал многие в разных вариациях. В зависимости от ограничений она лежит в разных классах. Мы рассматриваем ограничение на степень дерева. Эта задача $\bf NP$-трудная, но нам интересно найти полиномиальный алгоритм, который будет аппроксимировать с хорошей точностью.  
Пусть $Т$ - оптимальное остовное дерево, со степенью $∆$. Furer и Raghavachari в 1990 году предоставили аппроксимирующий алгоритм, который дает дерево со степенью $О(∆\log(n))$. Есть так же версия Штейнера для это задачи, когда дан не только граф, но и множество вершин. В этом случае нужно построить минимальное дерево, которое содержит эти вершины. По сути это обобщение исходной задачи, где множество вершин - это просто все вершины графа. В другой более ранней работе три математика Agrawal, Klein и Ravi показали, что даже более общая задача в версии Штейнера может быть аппроксимирована с точностью до логарифмического коэффициента. Мы же рассмотрим более позднюю работу Furer и Raghavachari 1992-ого года [1]. Там они описали полиномиальный алгоритм, который дает дерево степени $О(∆ + \log(n))$ для версии Штенейра и для ориентированного графа. Так же там есть улучшение это алгоритма для классической постановки задачи дающее результат не больше чем $∆ + 1$. Это улучшение мне и предстоит имплементировать.
У задачи аппроксимации есть много приложений. Например, для компьютеров в одной сети нужно передавать информацию друг другу, при этом минимизировав количество отправленных сообщений для каждого компьютера. Другое применение этой проблемы взято из области проектирования электрических сетей. Стоимость разделения входного электричества может быстро расти в зависимости от степени разделения. Нам нужны сети с небольшой максимальной степенью.
## Основная часть
Покажем, что задача поиска остовного дерева степени для произвольного фиксированного $k \ge 2$ является $\bf NP$-трудной.  При $k=2$ это задача $\mathsf UHAMPATH$. Она является $\bf NP$-трудной [2]. Для больших значений $k$ задача сводится к $\mathsf UHAMPATH$. Давайте к каждой вершине графа добавим $k - 2$ фейковые вершины. Эта функция работает за полиномиальное время от входа. Остовное дерево степени $k >2$ в полученном графе существует тогда и только тогда, когда в исходном графе существует гамильтонов путь. Значит, для $k > 2$ задача так же $\bf NP$-трудная, так сводится к $\bf NP$-трудной.
Теперь перейдем непосредственно к аппроксимирующему алгоритму. 
### Необходимые определения и теоремы
Сначала введем некоторые определения.   
Рассматриваем произвольное остовное дерево $Т$ для графа $G$. Обозначим за $р(u)$ степень вершины $u$ в дереве $T$. Мы будем пытаться уменьшить степень вершины итеративно по следующей схеме. Берем ребро $(u, v)$ из $G$, но не принадлежащее $T$. Пусть $С$ цикл, полученные при добавлении $(u, v)$ в $Т$. Предположим, что в цикле есть вершина такая, что $р(w) >= max(p(u), p(v)) + 2$. Тогда добавим ребро $(u, v)$, и удалим одно из цикла $C$ инцидентное $w$. Назовем эту операцию улучшением графа. 
Заметим, что $max(р(w), p(u), p(v))$ уменьшился хотя бы на единицу.  
***Определение:** LOT (locally optimal tree) - такое дерево, что ни одно ребро не из дерева не приводит к улучшениям.*  
Дальше максимальную степень дерева всегда будет обозначать за $k$.  
***Определение:** $X_i$ - множество вершин степени $i$ в дереве $T$.*  
***Определение:** $S_i$ - множество вершин степени не меньшей $i$ в дереве $T$.*   
***Определение:** Дано ребро $(u, v) \notin T$ из $G$. Рассмотрим вершину $w$ из цикла, получаемого, если в $T$ добавить ребро $(u, v)$. Если $p(u) \ge k - 1$, то скажем, что $u$ блокирует $w$. Если ни $u$, $v$ не блокируют $w$, то будем говорить, что $w$ улучшается ребром $(u, v)$.*  
Также нам понадобится следующая теорема:  
***Теорема:** Пусть $T$ остовное дерево степени $k$ для графа $G$. Обозначим степень минимального остовного дерева как $∆$. $S$ - множество вершин степени $k$. $B$ - множество вершин степени $k - 1$. После удаления $S \cup B$ из дерева $T$, мы получим некоторый лес $F$. Предположим, что в $G$ нет ребер соединяющих разные компоненты леса $F$, тогда $k \le ∆ + 1$.*  
**Доказательство:** Так как в $G$ нет ребер соединяющих разные компоненты леса $F$, то единственный способ соединить эти компоненты - это через вершины из $S \cup B$. Обозначим за $t$ - количество поддеревьев в $F$. Заметим, что $t$ равно количеству ребер, у которых ровно один конец лежит в $S \cup B$. Может показаться, что это неочевидный факт. Но это не так. Если мы удаляем из леса одно ребро, то какая-то компонента распадается на две. Будем просто итеративно удалять все ребра с одним концом в $S \cup B$. Ребер между вершинами $S \cup B$ не может быть больше, чем $|S| + |B| - 1$, так как мы рассматриваем только ребра дерева $T$. Тогда $t$ не меньше, чем $|S|k + |B|(k - 1) - 2(|S|+|B|-1)$. Заметим также, что всего ребер инцидентных $S \cup B$ ровно $t + |S| + |B| - 1$, так как если сжать до одной вершины все компоненты из леса $F$, то вместе с вершинами из $S \cup B$ мы должны получить дерево. Тогда для произвольного остовного дерева средняя степень вершин из $S \cup B$ равна $\frac{t + |S| + |B| - 1}{|S| + |B|}$, что не меньше чем $k - 1 - \frac{|B| - 1}{|S| + |B|}$. Максимальная степень для любого остовного дерева не меньше, чем средняя. Получаем, что $∆ \ge k - 1$.  
### Описание алгоритма
Прежде чем описать сам алгоритм, посмотрим на некоторые **наблюдения**. Предположим, что мы удалили $S_k$ - множество вершин максимальной степени из $T$. Получили лес $F$. Если в нашем графе $G$ нет ребер между разными компонентами из $F$, то мы победили, и $k = ∆$ (в теореме |B| = 0$). Иначе будем использовать такие ребра для улучшения какой-нибудь вершины из $S_k$. Если ребро не блокируется концами степени $k - 1$, то используем его для улучшения какой-нибудь вершины из $S_k$. Дальше посмотрим на оставшийся случай, пусть конец ребра $u$ блокирует $w$. Обозначим за $F_u$ компоненту из $F$ содержащую $u$. Было бы классно, если можно было улучшить вершину $u$ только с помощью вершин из $F_u$. Тогда бы мы сначала улучшили $u$, а потом и $w$. Спойлер: у нас получится добиться такой гарантии.  
**Перейдем к описанию самого алгоритма.**  
Берем произвольное остовное дерево $T$. Его можно получить с помощью любого обхода графа.
Удаляем все вершины из $S_k \cup S_{k-1}$ из $T$. Обозначим получившиеся компоненты связности как хорошие, а все вершины из $S_k \cup S_{k-1}$ как плохие. Если нет ребер между хорошими компонентами, то мы победили и $T$ искомое дерево. Иначе у нас есть какое-то ребро $(u, v)$ между двумя хорошими компонентами $F_u$ и $F_v$. Перебираем все такие ребра. Смотрим на цикл, получившийся при добавлении $(u, v)$. Если там есть вершина максимальной степени, то улучшаем её (если концы ребра блокируют её, то сначала улучшаем их). Таким образом мы на единицу уменьшили размер $S_k$. Иначе, в цикле есть не менее одной вершины степени $k-1$. Помечаем все вершины из цикла степени $k-1$ как хорошие, и объединяем все компоненты связности, через которые проходит наш цикл. И всё это будет работать благодаря чудесной лемме.  
***Лемма:** Любая блокирующая вершина $u$, помеченная как хорошая, может быть улучшена при помощи подграфа индуцированного только вершинами хорошей компоненты, содержащей $u$.*  
**Доказательство:** Будем доказывать некоторыми индукционными рассуждениями. Изначально у нас помечены как хорошие только вершины со степенями не больше чем $k - 2$. Если мы добавили вершину степени $k - 1$, то можно её улучшить с помощью цикла, из которого она пришла при добавлении в лес. Для этого добавим рассматриваемое на той итерации ребро, и уберем любое выходящие из вершины ребро. Получаем, что в любой момент в лесу любую блокирующую вершину можно сделать неблокирующей, не выходя за пределы одной компоненты.  
Тем самым мы доказали корректность работы нашего алгоритма.  
**Проанализируем асимптотику.**  
Наш алгоритм работает фазами, в каждую фазу мы уменьшаем количество вершин с максимальной степенью как минимум на одну. В случае успеха переходим в следующую фазу, иначе завершаем работу. Если в текущем дереве максимальная степень $k$, то может быть не более $O(n/k)$ фаз, при которых степень дерева не уменьшается. В деревьях мало ребер, а значит и мало вершин с большими степенями, меньше, чем $2n/k$. Если просуммировать для всех возможных $k$, то получим, что всего эпох $O(n\log n)$. Там возникает сумма гармонического ряда, который мы умеем оценивать логарифмом.  
Теперь посмотрим на время работы конкретной эпохи. Мы перебираем все ребра. Для каждого ребра между разными компонентами нам нужно искать путь в дереве. Так же для определения компоненты вершины будет использовать структуру непересекающиеся множества, которая работает почти за линейное время. В итоге получаем асимптотику $O(mn^2\log n \alpha(n))$, где $m$ - количество ребер, а $\alpha(n)$ - обратная функция Аккермана. В статье дана асимптотика $O(mn\log n \alpha(n))$. Думаю, к ней можно прийти, если подробнее расписать, что происходит при нахождении пути для каждого ребра. И скорее всего там не $O(mn)$, а просто $O(m)$. Но в любом случае, мы показали, что алгоритм работает за полиномиальное время.
## Источники
[1] M. Furer, B. Raghavachari, Approximating the Minimum Degree Spanning Tree to within One from the
Optimal Degree (1992)  
[2] Д. В. Мусатов, Сложность Вычислений (2016), МФТИ, стр. 37-38